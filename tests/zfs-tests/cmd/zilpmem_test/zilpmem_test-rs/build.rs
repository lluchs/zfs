use std::collections::BTreeMap;
use std::convert::TryFrom;
use std::path::PathBuf;

#[derive(serde::Deserialize)]
struct Metadata {
    ld_library_paths: Vec<String>,
    shared_libraries: Vec<String>,
    static_libraries: Vec<String>,
    static_library_paths: Vec<String>,
    linker_flags: Vec<String>,
}
fn main() {
    let cwd = &std::env::current_dir().unwrap();
    println!("current dir is {:?}", cwd);
    println!("env is {:#?}", std::env::vars().collect::<BTreeMap<_, _>>());

    let map_ld_library_path: Box<dyn Fn(PathBuf) -> _> =
        if let Ok(v) = std::env::var("ZILPMEM_TEST_BUILD_SUBSTITUTE_LD_LIBRARY_PATH") {
            let comps = v.split(':').map(PathBuf::from).collect::<Vec<_>>();
            assert_eq!(comps.len(), 2);
            Box::new(move |p| {
                let stripped = p.strip_prefix(&comps[0]).unwrap_or(&p);
                comps[1].join(stripped)
            })
        } else {
            Box::new(|p| p)
        };

    let mdjsonpath = PathBuf::from("./ld-metadata.json");
    assert!(mdjsonpath.is_file(), "{:?} must exist", mdjsonpath);
    let json = std::fs::read_to_string(&mdjsonpath)
        .expect("generated by Makefile generate-linking-metadata target");
    let Metadata {
        ld_library_paths,
        shared_libraries,
        static_libraries,
        static_library_paths,
        linker_flags,
    } = serde_json::from_str(&json).expect(&format!("deserialize metadata: {:?}", mdjsonpath));

    // these can only be handled by .cargo/config.toml because:
    // - https://github.com/rust-lang/cargo/issues/5077
    // - https://github.com/rust-lang/rfcs/issues/1766
    let _ = linker_flags;

    for p in ld_library_paths.iter().chain(static_library_paths.iter()) {
        let p = PathBuf::try_from(p).unwrap();
        let p = map_ld_library_path(p);
        assert!(
            p.is_dir(),
            "{:?} should exist, fix the generate-linking-metadata.py",
            p
        );
        // add to search path
        println!("cargo:rustc-link-search=native={}", p.display());
    }

    let ld_library_path = ld_library_paths
        .into_iter()
        .map(|p| {
            format!(
                "{}",
                map_ld_library_path(PathBuf::try_from(p).unwrap()).display()
            )
        })
        .collect::<Vec<_>>()
        .join(":");
    // make cargo run and cargo test work without setting LD_LIBRARY_PATH
    println!("cargo:rustc-env=LD_LIBRARY_PATH={}", ld_library_path);

    for p in shared_libraries {
        println!("adding shared library named {:?}", p);
        println!("cargo:rustc-link-lib=dylib={}", p)
    }
    for p in static_libraries {
        println!("adding shared library named {:?}", p);
        println!("cargo:rustc-link-lib=static={}", p)
    }

    // subprocess::Exec::cmd("make").arg("-C").arg(libzpooldir).join().unwrap();
}
