#!/usr/bin/env python3

import sys
import os
from pathlib import Path
import re

mode = Path(sys.argv[0]).name
comps = mode.split(".")
assert len(comps) == 3
assert comps[0] == "libtool-wrapper"
assert comps[2] == "py"
mode = comps[1]

procmacro = False
clean=[]
i = 1
while i < len(sys.argv):
	procmacro = procmacro or "proc_macro" in sys.argv[i]
	merged = sys.argv[i]
	if sys.argv[i] == "-L":
		merged = sys.argv[i] + sys.argv[i+1]
		i += 1
	i+=1
	clean.append(merged)

import json

with open("/tmp/libtool-wrapper.log", "a+") as f:
	json.dump({ "argv": sys.argv, "env": dict(**os.environ)}, f)
	f.write("\n")

if procmacro:
	os.execvp("cc", ["cc"] + sys.argv[1:])

libtool_common =  ["libtool", "-v", "--tag=CC", f"--mode={mode}"]

if mode == "link":
	cmd = libtool_common + ["cc"] + clean
	os.execvp("libtool",libtool_common + cmd)

if mode == "execute":
	cmd = sys.argv[1:]

	# do our own shitty libmagic so we don't depend on anything
	def is_libtool_wrapper_script(p):
		shebang = False
		with open(p, 'rb') as f:
			start = f.read(1024)
			if start.startswith(b'#!'):
				shebang = True
		libtool = False
		if shebang:
			with open(p, 'r') as f:
				for line in f:
					libtool = re.search("Generated by libtool", line) != None
					if libtool:
						break
		return libtool


	# cargo copies executables from target/*/deps/$name-$hash to target/deps/$name
	# but the problem is that the libtool files cannot be moved around because
	# they depend on the libtool-created `.libs` relative to their location
	#
	# XXX Ideally we could hook into cargo's copy-around logic but I can't
	# find it in the cargo source (HELP NEEDED!).
	# 
	# The workaround is to detect the case where we execute target/deps/$name
	# and if so scrape the libtool-generated script for the original
	# path which it luckily encodes there in libtool v2.4.6
	def convert_cargo_copied_targets_to_symlinks(execbinary):
		execbinary = Path(execbinary)
		assert execbinary.exists()
		if execbinary.match("target/*/*"):
			if execbinary.is_symlink():
				return # idempotent

			assert is_libtool_wrapper_script(execbinary)
			# extract the path
			with open(execbinary, "r") as f:
				lines = f.readlines()
				for line in lines:
					m = re.match(r"^# The (.+) program cannot be directly executed", line)
					if not m:
						continue
					originalpath = Path(m.group(1))
					assert originalpath.is_file()
					assert originalpath.is_absolute()
					assert is_libtool_wrapper_script(originalpath)
					assert (originalpath.parent / ".libs").is_dir()
					execbinary.unlink()
					execbinary.symlink_to(originalpath)
					break
		else:
			assert not is_libtool_wrapper_script(execbinary)

	convert_cargo_copied_targets_to_symlinks(cmd[0])
	os.execvp("libtool",libtool_common + cmd)
